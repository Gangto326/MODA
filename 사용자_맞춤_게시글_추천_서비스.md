# 카테고리 기반 사용자 맞춤 게시글 추천 서비스

# 1. 외부 API 서비스 종류 및 특징

- AWS Personalize
    - 장점
        1. AWS의 다른 서비스들과 쉽게 통합 가능
        2. 실시간 개인화 추천 가능
        3. 상품, 콘텐츠, 개인화된 순위 등의 다양한 Usecase를 지원함
    
    - 단점
        1. 초기 설정이 상대적으로 복잡함
        2. 데이터 준비와 학습에 시간이 많이 소용됨

<br>

- Google Cloud Recommendations AI
    - 장점
        1. YouTube, Google Play 등에서 사용하는 추천 기술 기반
        2. 복잡한 머신러닝 지식 없이도 사용 가능
        3. 상품 추천에 특화됨
    
    - 단점
        1. 다른 도메인 적용이 제한적
        2. 한국어 지원이 상대적으로 부족

<br>

- Azure Personalizer
    - 장점
        1. 강화학습 기반으로 지속적인 최적화
        2. 실시간 학습과 적용
        3. 도메인에 구애받지 않는 범용성
    
    - 단점
        1. 다른 서비스들에 비해 기능이 제한적
        2. 초기 성능이 상대적으로 낮을 수 있음

<br>

- Recombee
    - 장점
        1. 클라우드 제공업체에 종속되지 않음
        2. 직관적인 API와 빠른 설정, 구현 가능
    
    - 단점
        1. 대규모 처리에서 상대적으로 성능이 떨어질 수 있음
        2. 커스터마이징 옵션이 제한적

<br>

# 2. 사용자 맞춤 게시글 추천 서비스 자체 제작을 위한 데이터 정리

## 2-1. 추천 알고리즘 자체 제작을 위한 DB 정보 정리

### MongoDB (NoSQL, Document-Oriented Database)

- 같은 컬렉션에서도 다른 형태의 데이터를 저장할 수 있어 데이터의 구조가 유연함

- 쿼리의 성능이 빠름

- 대용량 데이터 처리에 강점을 가짐
    
    - Memory Mapping 방식 사용
          
          가상 메모리가 실제 데이터와 파일 사이에 존재
          지연 처리 및 캐싱 등을 처리할 수 있음

- 데이터가 늘어나도 수평적 확장 가능

    - Sharding 방식 사용

          데이터를 여러 서버에 물리적으로 분산하여 저장하는 방식

- 한 번에 여러 문서 수정시 원자성 보장이 어려움 (트랜잭션 제한)
    
    - 원자성: 완전하게 진행되어 종료되거나 그럴 수 없는 경우에는 실행을 하지 않는 것

- 조인 연산이 비효율적

### MySQL (RDBMS)

- 데이터 일관성 보장 (외래키 제약조건으로 참조 무결성 보장)

- 복잡한 조인 연산 & 메모리 사용이 효율적

- 스키마 변경이 매우 어려움

- 복잡하고 제한적인 Sharding 구현으로 수평적 확장의 한계

- 비정형 데이터에 대한 처리가 불편

### Elasticsearch (NoSQL DB, Java 오픈소스 분산 검색 엔진)

- 검색에 최적화된 인덱스 구조

- 전문 검색 기능 보유 및 오타 보정 설정

- 문서 수정시 전체 재인덱싱

- 검색 최적화를 위한 인덱스와 캐시로 많은 힙 메모리 필요

<br>

## 2-2. DB 자료구조와 Indexing

### B+Tree 자료구조

- MySQL과 MongoDB에서 사용하는 자료구조

- 내부 노드는 키를 저장하여 구간을 나누고, 모든 리프 노드가 실질적인 데이터를 가지고 있는 구조.

- 데이터의 삽입과 삭제, 탐색을 모두 O(log N)으로 수행할 수 있다.

- #### DB Indexing의 원리는 내부 노드의 키의 기준을 설정하는 것.

<br>

### 번외1: Indexing을 하지 않는 경우는 무엇을 기준으로 B+Tree가 구성되나요?

Indexing을 하지 않은 경우는 PK를 기준으로 B+Tree가 구성됩니다.

따라서, PK를 Auto Increment로 설정하면 삽입 속도가 O(1)이 됩니다. (모든 리프노드가 정렬되어있고, 삽입 과정은 리프 노드의 마지막이기 때문.)

<br>

### 번외2: PK를 Auto Increment와 UUID 중 어떤걸로 설정하는게 유리한가요?

Auto Increment는 DB에게 PK 생성을 의존하는 것이고, UUID는 개발자가 직접 PK를 만든다는 점에서 차이가 있습니다.

<br>

JPA를 사용하는 경우 Auto Increment 시에는 하나의 트랜잭션 내에서 INSERT 쿼리를 작성할 때 PK의 값이 null 이므로 DB에 매 순간 쿼리를 전송하여 PK 값을 얻어옵니다.

하지만, UUID를 사용하여 개발자가 직접 PK를 설정한다면 트랜잭션 커밋 시에 누적된 쿼리를 한 번에 전송할 수 있다는 장점이 있으나,<br>
사용자 개인의 트랜잭션 내에서 진행되는 로직이므로 성능상의 이점이 크게발생하는 경우는 매우 드뭅니다.

<br>

PK를 UUID로 설정하면 삽입 속도가 O(log N)으로 상승합니다.<br>
다만, O(1)과 O(log N)의 속도 측면에서의 차이는 체감이 될 만큼 크지 않습니다.

<br>

Auto Increment를 사용하는 경우 동시에 INSERT쿼리가 발생하는 동시성 문제가 발생할 수 있으나,<br>
이 또한 MySQL 내부에서 각자의 트랜잭션에 따라 서로 다른 PK를 할당해주기 때문에 크게 문제가 되지 않습니다.

<br>

### 그렇다면 UUID를 사용하는 이유와 그 이점에는 뭐가 있나요?

1. 기업 인수 or 병합 과정 / 로직 변경 등 공통 테이블 (User 테이블 등) 병합 시의 PK 충돌 방지.

2. PK의 유추를 어렵게 하여 보안 측면에서의 이점을 가질 수 있음.

<br>

### Inverted Index

Elasticsearch에서 사용하는 자료구조

    예시)

    원본 문서:
    Doc1: "The quick brown fox"
    Doc2: "The lazy brown dog"
    Doc3: "Quick brown rabbits"

    역색인 구조:
    the   -> Doc1, Doc2
    quick -> Doc1, Doc3
    lazy  -> Doc2
    brown -> Doc1, Doc2, Doc3
    fox   -> Doc1
    dog   -> Doc2
    rabbits-> Doc3

모든 고유 용어를 저장하고, FST(Finite State Transducer) 자료구조를 사용하여 메모리 효율적인 저장을 합니다.

    검색 과정)

    검색어: "quick brown"

    1) 용어 사전에서 'quick' 검색
    2) quick의 포스팅 리스트 가져옴 -> [Doc1, Doc3]
    3) 용어 사전에서 'brown' 검색
    4) brown의 포스팅 리스트 가져옴 -> [Doc1, Doc2, Doc3]
    5) 두 포스팅 리스트의 교집합 -> [Doc1, Doc3]

### FST(Finite State Transducer) 자료구조란?

마치 Trie와 같은 문자열을 저장하기 위한 자료구조입니다.

차이점으로는 같은 문자열을 공유하고 있는 문자들의 검색에서
Trie는 중복 탐색이 이루어질 수 있지만, FST는 상태와 전이를 이용하여 중복 탐색을 하지 않습니다.

단, 새로운 문자가 생성되어 추가되는 경우 이미 전부 짜여진 FST 구조를 변경해야 하는 단점이 있습니다.

<br>

### Hash Table과 Sorted Set

- Redis와 같이 메모리 기반의 저장공간을 사용하는 DB에서 사용하는 자료구조



<br>

### 2-3. Caching 전략 구상